---
title: "R Devlopment of Matching for Stitches"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '4'
    toc_float: yes
    number_sections: true
date: "`r format(Sys.time(), '%d %B, %Y')`"
---


# Intro notes & set up 

On March 15th we spoke about how we want to have some data to work with ASAP that can be used as proof of progress at the meeting on April 12th. To make speed this process up we decided to do some of the inital implmentation of the matching by nearest neighboor in R before translating it into python with good software design, this is a team effort and because the baton will be passed between memeber here are some note, potenitally excessive notes about what is going on. 

Materials 

* `stitches/notebooks/produce_nearest_neighboor_inputs.py`: the python script that produces target and archive data that we will be used in the matching. This is data of values and rate of change for the different chunks of smoothed CanESM data. The target data contians data from a single experiment/ ensemble realization. The archive data contains this data for all of avaiable CanESM outputs. The outputs of this script are saved as csv files in `stitches/notebooks/stitches_dev/inputs` to be used in the R dev stage.
* `stitches/notebooks/stitches_dev`: contains the materials for the R development of the matching based on the nearest neighbor. 
    * `nearest_neighboor_matching.R`: the functions that are used to find the nearest neighboor based on the euclidean distance between the target and archive data sets. Note that this only selects the first nearest neighbor, it ignores cases where there are equa distant ties :( but that is a problem for another day. I spent a bit of time trying to find a pacakge/existing function that would be helpful here but there was nothing in R or python that looked like what we were looking for... 
    * `dev_notes.Rmd`: this document that walks through the matching process & the progress made on stitiching together the global mean time series so far. 
    * `stitching_functions.R`: an attempt at writing something that would use the information from the matched data frame to stitch together the global mean temp anomalies. It is unideal and there are probably some issues, the transition from historical to next experiment is missing data!
    
    
```{r, message = FALSE, warning = FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(knitr)
# library(kableExtra)


# Load the functions that we will use! 
source("nearest_neighbor_matching.R")
source("stitching_functions.R")


# The tgav anomaly data (smoothed?)
tgav_data <- read.csv("inputs/tgav_data.csv", stringsAsFactors = FALSE)

# The archive of data: tgav anomalies converted to chunked windows with 
# fx and dx calculated.
archive_data <- read.csv('inputs/archive_data.csv', stringsAsFactors = FALSE)

# The target dta is just the archive data, filtered to be ssp245 realization 1.
# Saved and read in for convenience.
target_data <- read.csv("inputs/target_data.csv", stringsAsFactors = FALSE)
```

# Goal
We want to figure out what the nearest neighbor matching is doing in Kalyn's original write up. We have _not_ yet fixed the time jump in stitched Tgavs.

# Nearest Neighbor Matching 

We will use the function `match_nearest_neighbor` to match target data to its nearest neighboog defined that the observation in the arhive that minimizes the euclidean distance. Note that this picks the first nearest neighboor it runs into, it does not account for ties, 

Proof of concept, if we read in the entire archive, this function should self select the target data, noramlly the target data will not also be included in the target data. 

## Match with archive = boundary secnarios ssp126 and ssp585 

Now what happens when the archive scenario only consists of the two extreme scenarios. We should see that the different scenarios are being selected from the archive. 
 
```{r}
archive_ssp126_ssp585 <- filter(archive_data, experiment %in% c("ssp126", "ssp585"))

# let's shuffle the entries 
set.seed(42)
rows <- sample(nrow(archive_ssp126_ssp585), replace = FALSE) 
archive_ssp126_ssp585 <- archive_ssp126_ssp585[rows, ]

# Now match the target data with the limited archive 
boundary_ssps_match <- match_nearest_neighbor(target_data = target_data, 
                                              archive_data = archive_ssp126_ssp585)
```

When we check to see the sources of the matched entries from the archive we should see mulitple experiments and ensemble members! 

```{r}
boundary_ssps_match %>%
  select(target_model, archive_model,
         target_experiment, archive_experiment,
         target_ensemble, archive_ensemble) %>%
  distinct %>%
  kable()
```


Now let's over lay the dx vs fx plots, note that lines are drawn between the pairs of data that are matched if no line is visible or the dot appears purple then it means that the matched values are stacked on top of one another. 

```{r, echo=FALSE, warning=FALSE,message=FALSE}
ggplot() + 
  geom_point(data = archive_ssp126_ssp585, 
             aes(fx, dx, color = "no match"), alpha = 0.1) + 
  geom_point(data = boundary_ssps_match, aes(archive_fx, archive_dx,  
                                             color = "matched archive data")) + 
  geom_point(data = boundary_ssps_match, aes(target_fx, target_dx,  
                                             color = "target data"), alpha = 0.4) + 
  geom_segment(data = boundary_ssps_match, aes(x = target_fx, y = target_dx, 
                        xend = archive_fx, yend =  archive_dx), alpha = 0.4) +
 scale_color_manual(values = c("matched archive data" = "red", 
                               "target data" = "blue", "no match" = "grey"))+
  theme_bw() + 
  labs(y = "dx (rate of change per chunk, degC/year)", 
       x = "fx (value of median temperature per chunk, degC)", 
       title = "Matching target (ssp245) with archive (ssp126 and ssp585)" )
```


## Investigate the matching

It appears from the last scatter plot of figures that the points being selected as minimizing distance don't (visually) appear to actually be the minimized points. Label the points of the target data to make things a little simpler:

```{r, echo=FALSE, warning=FALSE,message=FALSE}
ggplot() + 
  geom_point(data = archive_ssp126_ssp585, 
             aes(fx, dx, color = "no match"), alpha = 0.3) + 
  geom_point(data = boundary_ssps_match, aes(archive_fx, archive_dx,  
                                             color = "matched archive data")) + 
  geom_point(data = boundary_ssps_match, aes(target_fx, target_dx,  
                                             color = "target data"), alpha = 0.4) + 
  geom_text(data = boundary_ssps_match, aes(target_fx, target_dx, 
                                            label = target_year), size=2) +
  geom_segment(data = boundary_ssps_match, aes(x = target_fx, y = target_dx, 
                        xend = archive_fx, yend =  archive_dx), alpha = 0.4) +
 scale_color_manual(values = c("matched archive data" = "red", 
                               "target data" = "blue", "no match" = "grey"))+
  theme_bw() + 
  labs(y = "dx (rate of change per chunk, degC/year)", 
       x = "fx (value of median temperature per chunk, degC)", 
       title = "Matching target (ssp245) with archive (ssp126 and ssp585)" )
```

Select a few individual points where it seems to be wrong. Data points for `target_year > 2016`. It looks like the first time window that includes any future years (centered around 2016) is fine, but that as soon as we move to windows made entirely of future years, the matches get weird. Especially the windows centered at 2025, 2034, 2043, 2052.



The window centered on 2025 is up first.
Let's re-do the plot and zoom in around there.

```{r,echo=FALSE, warning=FALSE,message=FALSE}
# define some specific years to investigate
yrs <- c(2025, 2034, 2043, 2052)

# save the original match made by the above code for comparison.
boundary_ssps_match %>%
  filter(target_year %in% yrs) %>%
  distinct ->
  orig_match

ggplot() + 
  geom_point(data = archive_ssp126_ssp585, 
             aes(fx, dx, color = "no match"), alpha = 0.5) + 
  geom_text(data= archive_ssp126_ssp585, 
            aes(fx, dx, label = interaction(experiment, ensemble, year)),
            size = 1.8) +
  geom_point(data = orig_match, aes(archive_fx, archive_dx,  
                                             color = "matched archive data"), alpha = 0.4) + 
  geom_point(data = orig_match, aes(target_fx, target_dx,  
                                             color = "target data"), alpha = 0.4) + 
  geom_text(data = orig_match, aes(target_fx, target_dx, 
                                            label = target_year), size=2) +
  geom_segment(data = orig_match, aes(x = target_fx, y = target_dx, 
                        xend = archive_fx, yend =  archive_dx), alpha = 0.4) +
 scale_color_manual(values = c("matched archive data" = "red", 
                               "target data" = "blue", "no match" = "grey")) +
  xlim(.85, .95) + ylim(.04, .05)+
  theme_bw() + 
  labs(y = "dx (rate of change per chunk, degC/year)", 
       x = "fx (value of median temperature per chunk, degC)", 
       title = "Matching target (ssp245) with archive (ssp126 and ssp585)" ) 
```

So it _should_ be matching to a value from ssp585 realization 22, instead of the value it is matching to (from ssp126 realization 25).

## The problem
There's the problem: The ssp585 realization 22 only _looks_ closer to the target point because the x and y axes have such different units (degC vs degC/year) and therefore are such different orders of magnitude. A tick mark on the x-axis is a much bigger number than a tick mark on the y-axis.

We re-make the figure on a consistent axis framing and it's clear that the matching is numerically working as intended:

```{r,echo=FALSE, warning=FALSE,message=FALSE}

archive_ssp126_ssp585 %>%
  filter(fx >= 0.8 & fx <= 1,
         dx >= 0.04 & dx <= 0.05,
         (experiment == 'ssp585' & ensemble == 'r22i1p1f1') |
            (experiment == 'ssp126' & ensemble == 'r25i1p1f1') ) ->
  archivedata


ggplot() + 
  geom_point(data = distinct(archivedata), 
             aes(fx, dx, color = "no match"), alpha = 0.5) + 
  geom_text(data= archivedata, 
            aes(fx, dx, label = interaction(experiment, ensemble, year)),
            size = 1.8) +
  geom_point(data = orig_match, aes(archive_fx, archive_dx,  
                                             color = "matched archive data"), alpha = 0.4) + 
  geom_point(data = orig_match, aes(target_fx, target_dx,  
                                             color = "target data"), alpha = 0.4) + 
  geom_text(data = orig_match, aes(target_fx, target_dx, 
                                            label = target_year), size=2) +
  geom_segment(data = orig_match, aes(x = target_fx, y = target_dx, 
                        xend = archive_fx, yend =  archive_dx), alpha = 0.4) +
 scale_color_manual(values = c("matched archive data" = "red", 
                               "target data" = "blue", "no match" = "grey")) +
  xlim(.875, .925) + ylim(-.005, .095)+
  theme_bw() + 
  labs(y = "dx (rate of change per chunk, degC/year)", 
       x = "fx (value of median temperature per chunk, degC)", 
       title = "Matching target (ssp245) with archive (ssp126 and ssp585)" ) 
```


# Options to fix

After consultation with Kalyn and Claudia, we will investigate two options:

1. We will work with a 'new' distance metric with units of degC by working with window_size*dx in our minimization
2. We will work with a 'new' distance metric (unitless) by standardizing both fx and dx by their respective standard deviations.

## Minimizing on window-size*dx

This results in a distance in units of degC.

```{r}
window_size <- 9

archive_data %>% 
  filter(experiment %in% c("ssp126", "ssp585")) %>%
  mutate(orig_dx = dx,
         dx = window_size * dx)->
  archive_opt1

# let's shuffle the entries 
set.seed(42)
rows <- sample(nrow(archive_opt1), replace = FALSE) 
archive_opt1 <-archive_opt1[rows, ]


target_data %>%
   mutate(orig_dx = dx,
         dx = window_size * dx)->
  target_opt1


# Now match the target data with the limited archive 
boundary_ssps_match_opt1 <- match_nearest_neighbor(target_data = target_opt1, 
                                              archive_data = archive_opt1)
```


```{r, echo=FALSE, warning=FALSE,message=FALSE, fig.width=12}
p <- ggplot() + 
  geom_point(data = archive_opt1, 
             aes(fx, dx, color = "no match"), alpha = 0.3) + 
  geom_point(data = boundary_ssps_match_opt1, aes(archive_fx, archive_dx,  
                                             color = "matched archive data")) + 
  geom_point(data = boundary_ssps_match_opt1, aes(target_fx, target_dx,  
                                             color = "target data"), alpha = 0.4) + 
  # geom_text(data = boundary_ssps_match_opt1, aes(target_fx, target_dx, 
  #                                           label = target_year), size=2) +
    geom_segment(data = boundary_ssps_match_opt1, aes(x = target_fx, y = target_dx, 
                        xend = archive_fx, yend =  archive_dx), alpha = 0.4) +
 scale_color_manual(values = c("matched archive data" = "red", 
                               "target data" = "blue", "no match" = "grey"))+
  coord_fixed() + 
  theme_bw() + 
  labs(y = "adj. dx (degC)", 
       x = "fx (value of median temperature per chunk, degC)", 
       title = "Matching target (ssp245) with archive (ssp126 and ssp585)" )
p

ggsave('opt1_scatter.png', p, width = 12, height = 4, units = 'in')
```


## Minimizing standardized fx and dx

This results in a unitless distance.

### use standard deviations for each experiment

```{r}
# get the standard deviations

archive_data %>%
  group_by(variable, model, experiment) %>%
  summarize(sd_fx = sd(fx),
            sd_dx = sd(dx)) %>%
  ungroup ->
  archive_sdA


archive_data %>% 
  filter(experiment %in% c("ssp126", "ssp585")) %>%
  left_join(archive_sdA, by=c('variable', 'model', 'experiment')) %>% 
  mutate(fx_old = fx,
         fx = fx/sd_fx,
         dx_old = dx,
         dx = dx/sd_dx) ->
  archive_opt2a

# let's shuffle the entries 
set.seed(42)
rows <- sample(nrow(archive_opt2a), replace = FALSE) 
archive_opt2a <-archive_opt2a[rows, ]


target_data %>%
   left_join(archive_sdA, by=c('variable', 'model', 'experiment')) %>% 
  mutate(fx_old = fx,
         fx = fx/sd_fx,
         dx_old = dx,
         dx = dx/sd_dx) ->
  target_opt2a


# Now match the target data with the limited archive 
boundary_ssps_match_opt2a <- match_nearest_neighbor(target_data = target_opt2a, 
                                              archive_data = archive_opt2a)
```


```{r, echo=FALSE, warning=FALSE,message=FALSE, fig.width=12}
p <- ggplot() + 
  geom_point(data = archive_opt2a, 
             aes(fx, dx, color = "no match"), alpha = 0.3) + 
  geom_point(data = boundary_ssps_match_opt2a, aes(archive_fx, archive_dx,  
                                             color = "matched archive data")) + 
  geom_point(data = boundary_ssps_match_opt2a, aes(target_fx, target_dx,  
                                             color = "target data"), alpha = 0.4) + 
  # geom_text(data = boundary_ssps_match_opt1, aes(target_fx, target_dx, 
  #                                           label = target_year), size=2) +
    geom_segment(data = boundary_ssps_match_opt2a, aes(x = target_fx, y = target_dx, 
                        xend = archive_fx, yend =  archive_dx), alpha = 0.4) +
 scale_color_manual(values = c("matched archive data" = "red", 
                               "target data" = "blue", "no match" = "grey"))+
  coord_fixed() + 
  theme_bw() + 
  labs(y = "adj. dx (unitless)", 
       x = "adj. fx (unitless)", 
       title = "Matching target (ssp245) with archive (ssp126 and ssp585)" )
p

ggsave('opt2a_scatter.png', p, width = 12, height = 10, units = 'in')
```


### use standard deviations for each experiment*ensemble

```{r}
# get the standard deviations

archive_data %>%
  group_by(variable, model, experiment, ensemble) %>%
  summarize(sd_fx = sd(fx),
            sd_dx = sd(dx)) %>%
  ungroup ->
  archive_sdB


archive_data %>% 
  filter(experiment %in% c("ssp126", "ssp585")) %>%
  left_join(archive_sdB, by=c('variable', 'model', 'experiment', 'ensemble')) %>% 
  mutate(fx_old = fx,
         fx = fx/sd_fx,
         dx_old = dx,
         dx = dx/sd_dx) ->
  archive_opt2b

# let's shuffle the entries 
set.seed(42)
rows <- sample(nrow(archive_opt2b), replace = FALSE) 
archive_opt2b <-archive_opt2b[rows, ]


target_data %>%
   left_join(archive_sdB, by=c('variable', 'model', 'experiment', 'ensemble')) %>% 
  mutate(fx_old = fx,
         fx = fx/sd_fx,
         dx_old = dx,
         dx = dx/sd_dx) ->
  target_opt2b


# Now match the target data with the limited archive 
boundary_ssps_match_opt2b <- match_nearest_neighbor(target_data = target_opt2b, 
                                              archive_data = archive_opt2b)
```


```{r, echo=FALSE, warning=FALSE,message=FALSE, fig.width=12}
p <- ggplot() + 
  geom_point(data = archive_opt2b, 
             aes(fx, dx, color = "no match"), alpha = 0.3) + 
  geom_point(data = boundary_ssps_match_opt2b, aes(archive_fx, archive_dx,  
                                             color = "matched archive data")) + 
  geom_point(data = boundary_ssps_match_opt2b, aes(target_fx, target_dx,  
                                             color = "target data"), alpha = 0.4) + 
  # geom_text(data = boundary_ssps_match_opt1, aes(target_fx, target_dx, 
  #                                           label = target_year), size=2) +
    geom_segment(data = boundary_ssps_match_opt2b, aes(x = target_fx, y = target_dx, 
                        xend = archive_fx, yend =  archive_dx), alpha = 0.4) +
 scale_color_manual(values = c("matched archive data" = "red", 
                               "target data" = "blue", "no match" = "grey"))+
  coord_fixed() + 
  theme_bw() + 
  labs(y = "adj. dx (unitless)", 
       x = "adj. fx (unitless)", 
       title = "Matching target (ssp245) with archive (ssp126 and ssp585)" )
p

ggsave('opt2b_scatter.png', p, width = 12, height = 10, units = 'in')
```



# Stitched time series

```{r}
out1 <- stitch_global_mean(data = tgav_data, match = boundary_ssps_match)
out1$name <- "boundary ssp match"
```


```{r}
# prepare the comparison data this is the data that we are trying to emulate, which we smoothed in python. 
tgav_data %>% 
  dplyr::filter(experiment %in% c(unique(target_data$experiment), "historical") & ensemble == unique(target_data$ensemble) & model == unique(target_data$model)) -> 
  comparison
```


```{r, warning=FALSE, message=FALSE}
ggplot() + 
  geom_line(data = comparison, aes(year, value, color = "target data")) + 
  geom_line(data = out1, aes(year, value, color = "stitched 1"), alpha = 0.6) + 
  theme_bw() + 
  labs(y = 'Global Temp', 
       x = "Year") + 
  scale_color_manual(values = c("target data" = "grey", "stitched 1" = "red"))
```

